extends Interactable

@export var dialogue_file: String = "res://dialogues/phone_dialogue.dialogue"
@export var target_scene: String = "res://bar.tscn"
@export var item_name: String = "phone"

var scene_change_triggered: bool = false
var last_selected_response: String = ""
var dialogue_label = null
var is_popup_visible: bool = false
var dialogue_has_ended: bool = false
var dialogue_in_progress: bool = false
var original_position: Vector2
var original_scale: Vector2
var original_z_index: int

func _ready() -> void:
	dialogue_file = "res://dialogues/phone_dialogue.dialogue"
	prompt_text = "ğŸ“± æŸ¥çœ‹æ‰‹æœº"
	
	super()
	
	enable_hover_hint = false
	if prompt_label:
		prompt_label.visible = false
		prompt_label.queue_free()
	
	original_position = position
	original_scale = scale
	original_z_index = z_index
	
	modulate.a = 0.0
	visible = false
	
	print("âœ“ " + item_name + " åˆå§‹åŒ–å®Œæˆ")

func _trigger_interact() -> void:
	if dialogue_in_progress:
		print("âš ï¸ " + item_name + " å¯¹è¯è¿›è¡Œä¸­ï¼Œå¿½ç•¥ç‚¹å‡»")
		return
	
	if dialogue_has_ended:
		print("âš ï¸ " + item_name + " å¯¹è¯å·²å®Œæˆï¼Œå¿½ç•¥ç‚¹å‡»")
		return
	
	if is_interacting:
		return
	
	is_interacting = true
	
	bring_to_front()
	hide_other_item()
	
	_on_interact()
	_unlock_after_delay()

func _unlock_after_delay() -> void:
	await get_tree().create_timer(0.2).timeout
	is_interacting = false

func bring_to_front():
	z_index = 100
	print("ğŸ“± " + item_name + " ç½®äºæœ€å‰")

func hide_other_item():
	var other_item_name = "earphone" if item_name == "phone" else "phone"
	var world = get_node_or_null("/root/world")
	if world:
		var other_item = world.find_node_recursive(world, other_item_name)
		if other_item and other_item.has_method("fade_out_temporarily"):
			other_item.fade_out_temporarily()

func fade_out_temporarily():
	var tween = create_tween()
	tween.tween_property(self, "modulate:a", 0.2, 0.3)

func restore_visibility():
	if is_popup_visible and not dialogue_in_progress:
		var tween = create_tween()
		tween.tween_property(self, "modulate:a", 1.0, 0.3)

func show_popup():
	if is_popup_visible:
		return
	
	is_popup_visible = true
	dialogue_has_ended = false
	dialogue_in_progress = false
	scene_change_triggered = false
	last_selected_response = ""
	visible = true
	
	print("ğŸ“± " + item_name + " å¼¹å‡ºåŠ¨ç”»å¼€å§‹...")
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	tween.tween_property(self, "modulate:a", 1.0, 0.3)
	
	scale = original_scale * 0.5
	tween.tween_property(self, "scale", original_scale, 0.3).set_trans(Tween.TRANS_BACK).set_ease(Tween.EASE_OUT)
	
	await tween.finished
	
	shake_item()

func shake_item():
	print("ğŸ“³ " + item_name + " éœ‡åŠ¨ä¸­...")
	
	var shake_count = 6
	var shake_intensity = 8.0
	var shake_duration = 0.05
	
	for i in range(shake_count):
		var tween = create_tween()
		
		var offset = Vector2(
			randf_range(-shake_intensity, shake_intensity),
			randf_range(-shake_intensity, shake_intensity)
		)
		
		tween.tween_property(self, "position", original_position + offset, shake_duration)
		await tween.finished
	
	var tween = create_tween()
	tween.tween_property(self, "position", original_position, 0.1)
	await tween.finished
	
	print("âœ“ éœ‡åŠ¨å®Œæˆ")

func _input(event: InputEvent) -> void:
	if not is_popup_visible:
		return
	
	if not dialogue_has_ended:
		return
	
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			hide_item()

func hide_item():
	if not is_popup_visible:
		return
	
	print("ğŸ“± " + item_name + " æ·¡å‡º...")
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	tween.tween_property(self, "modulate:a", 0.0, 0.5)
	tween.tween_property(self, "scale", original_scale * 0.8, 0.5)
	
	await tween.finished
	
	visible = false
	is_popup_visible = false
	z_index = original_z_index
	
	restore_other_item()
	
	var world = get_node_or_null("/root/world")
	if world and world.has_method("check_all_items_hidden"):
		world.check_all_items_hidden()
	
	print("âœ“ " + item_name + " å·²éšè—")

func restore_other_item():
	var other_item_name = "earphone" if item_name == "phone" else "phone"
	var world = get_node_or_null("/root/world")
	if world:
		var other_item = world.find_node_recursive(world, other_item_name)
		if other_item and other_item.has_method("restore_visibility"):
			other_item.restore_visibility()

func _on_interact() -> void:
	print("\n==================================================")
	print(">>> " + item_name + " è¢«ç‚¹å‡» <<<")
	print("==================================================")
	
	scene_change_triggered = false
	last_selected_response = ""
	dialogue_has_ended = false
	dialogue_in_progress = true
	
	show_dialogue()

func show_dialogue() -> void:
	print("  [1] å¼€å§‹æ˜¾ç¤ºå¯¹è¯...")
	
	if not is_instance_valid(DialogueManager):
		print("  âŒ DialogueManager ä¸å­˜åœ¨")
		dialogue_in_progress = false
		return
	
	if not FileAccess.file_exists(dialogue_file):
		print("  âŒ å¯¹è¯æ–‡ä»¶ä¸å­˜åœ¨: " + dialogue_file)
		dialogue_in_progress = false
		return
	
	var dialogue_resource = load(dialogue_file)
	if dialogue_resource == null:
		print("  âŒ æ— æ³•åŠ è½½å¯¹è¯")
		dialogue_in_progress = false
		return
	
	print("  [2] å¯¹è¯èµ„æºåŠ è½½æˆåŠŸ")
	
	var balloon = DialogueManager.show_example_dialogue_balloon(dialogue_resource, "start")
	
	if balloon:
		print("  [3] å¯¹è¯å®¹å™¨å·²åˆ›å»º")
		
		find_and_connect_signals(balloon)
		
		if DialogueManager.has_signal("dialogue_ended"):
			if DialogueManager.dialogue_ended.is_connected(_on_dialogue_ended):
				DialogueManager.dialogue_ended.disconnect(_on_dialogue_ended)
			DialogueManager.dialogue_ended.connect(_on_dialogue_ended)
			print("  âœ“ å·²è¿æ¥ DialogueManager.dialogue_ended")
		
		print("\n  [4] ç­‰å¾…ç©å®¶é€‰æ‹©...\n")

func find_and_connect_signals(node: Node, depth: int = 0):
	for sig in node.get_signal_list():
		var sig_name = sig.name
		
		if sig_name == "actioned":
			if not node.actioned.is_connected(_on_actioned):
				node.actioned.connect(_on_actioned)
				print("  âœ“ è¿æ¥äº† actioned ä¿¡å·")
		
		if sig_name == "response_selected":
			if not node.response_selected.is_connected(_on_response_selected):
				node.response_selected.connect(_on_response_selected)
				print("  âœ“ è¿æ¥äº† response_selected ä¿¡å·")
		
		if sig_name == "dialogue_ended":
			if not node.dialogue_ended.is_connected(_on_dialogue_ended):
				node.dialogue_ended.connect(_on_dialogue_ended)
	
	for child in node.get_children():
		find_and_connect_signals(child, depth + 1)

func _on_actioned(action):
	print("\nâš¡ actioned ä¿¡å·è§¦å‘ï¼")
	print("  æ•°æ®: " + str(action))
	
	# ğŸ”¥ æ£€æŸ¥æ˜¯å¦æœ‰ next_id å±æ€§
	if "next_id" in action:
		var next_id = str(action.next_id)
		print("  â†’ è·³è½¬èŠ‚ç‚¹: " + next_id)
		
		if next_id == "midnight":
			scene_change_triggered = true
			print("  âœ“âœ“âœ“ æ£€æµ‹åˆ° midnight èŠ‚ç‚¹ï¼")

# ğŸ”¥ ä¿®å¤ï¼šDialogueResponse å¯¹è±¡çš„å¤„ç†
func _on_response_selected(response):
	print("\nğŸ¯ response_selected ä¿¡å·è§¦å‘ï¼")
	print("  æ•°æ®ç±»å‹: " + str(response.get_class()))
	print("  æ•°æ®: " + str(response))
	
	# ğŸ”¥ ç›´æ¥è®¿é—® .text å±æ€§ï¼ˆä¸ç”¨ .has()ï¼‰
	var response_text = ""
	
	# å°è¯•è·å– text å±æ€§
	if "text" in response:
		response_text = str(response.text)
	else:
		# å¦‚æœæ˜¯ DialogueResponse å¯¹è±¡ï¼Œç›´æ¥è½¬å­—ç¬¦ä¸²
		response_text = str(response)
	
	last_selected_response = response_text
	print("  â†’ ç”¨æˆ·é€‰æ‹©: " + last_selected_response)
	
	# ğŸ”¥ æ£€æµ‹æ˜¯å¦åŒ…å« "YES"ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
	var lower_text = last_selected_response.to_lower()
	if "yes" in lower_text:
		scene_change_triggered = true
		print("  âœ“âœ“âœ“ æ£€æµ‹åˆ° YES é€‰é¡¹ï¼Œå°†åˆ‡æ¢åœºæ™¯ï¼")

# ğŸ”¥ å»¶è¿Ÿæ£€æŸ¥æœºåˆ¶
func _on_dialogue_ended(resource):
	print("\nğŸ“• " + item_name + " å¯¹è¯ç»“æŸä¿¡å·è§¦å‘")
	print("  â†’ ç­‰å¾… 0.2 ç§’è®©æ‰€æœ‰ä¿¡å·å¤„ç†å®Œ...")
	
	# ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©æ‰€æœ‰ä¿¡å·éƒ½å¤„ç†å®Œ
	await get_tree().create_timer(0.2).timeout
	
	print("\nğŸ“• " + item_name + " å¯¹è¯çœŸæ­£ç»“æŸï¼")
	print("  scene_change_triggered = " + str(scene_change_triggered))
	print("  last_selected_response = " + last_selected_response)
	
	# ğŸ”¥ æœ€åæ£€æŸ¥ï¼šå¦‚æœé€‰æ‹©åŒ…å« YESï¼Œå¼ºåˆ¶åˆ‡æ¢åœºæ™¯
	var lower_text = last_selected_response.to_lower()
	if "yes" in lower_text:
		scene_change_triggered = true
		print("  âœ“ é€šè¿‡æ–‡æœ¬æ£€æµ‹ï¼Œå¼ºåˆ¶æ ‡è®°ä¸ºåˆ‡æ¢åœºæ™¯")
	
	dialogue_has_ended = true
	dialogue_in_progress = false
	
	z_index = original_z_index
	restore_other_item()
	
	var world = get_node_or_null("/root/world")
	if world and world.has_method("mark_dialogue_completed"):
		world.mark_dialogue_completed(item_name)
	
	if scene_change_triggered:
		print("  âœ“âœ“âœ“ å°†åˆ‡æ¢åœºæ™¯åˆ°: " + target_scene)
		await get_tree().create_timer(0.5).timeout
		change_scene()
	else:
		print("  â†’ ä¿æŒå½“å‰åœºæ™¯")
		print("  ğŸ’¡ æç¤ºï¼šç°åœ¨å¯ä»¥ç‚¹å‡»å±å¹•ä»»æ„å¤„éšè—ç‰©å“")

func change_scene():
	print("\nğŸ¬ğŸ¬ğŸ¬ å¼€å§‹åˆ‡æ¢åœºæ™¯ ğŸ¬ğŸ¬ğŸ¬")
	print("  ç›®æ ‡åœºæ™¯: " + target_scene)
	
	if not FileAccess.file_exists(target_scene):
		print("  âŒ åœºæ™¯æ–‡ä»¶ä¸å­˜åœ¨: " + target_scene)
		print("  â†’ è¯·ç¡®è®¤æ–‡ä»¶è·¯å¾„æ˜¯å¦æ­£ç¡®")
		return
	
	print("  âœ“ åœºæ™¯æ–‡ä»¶å­˜åœ¨")
	print("  â†’ åˆ›å»ºæ·¡å‡ºæ•ˆæœ...")
	
	var fade = ColorRect.new()
	fade.color = Color.BLACK
	fade.set_anchors_preset(Control.PRESET_FULL_RECT)
	fade.mouse_filter = Control.MOUSE_FILTER_IGNORE
	get_tree().root.add_child(fade)
	fade.modulate.a = 0.0
	
	print("  â†’ å¼€å§‹æ·¡å‡ºåŠ¨ç”»...")
	var tween = create_tween()
	tween.tween_property(fade, "modulate:a", 1.0, 1.0)
	await tween.finished
	
	print("  â†’ æ‰§è¡Œåœºæ™¯åˆ‡æ¢...")
	var result = get_tree().change_scene_to_file(target_scene)
	
	if result == OK:
		print("  âœ“âœ“âœ“ åœºæ™¯åˆ‡æ¢æˆåŠŸï¼")
	else:
		print("  âŒ åœºæ™¯åˆ‡æ¢å¤±è´¥ï¼Œé”™è¯¯ç : " + str(result))
