extends Interactable

@export var dialogue_file: String = "res://dialogues/phone_dialogue.dialogue"
@export var target_scene: String = "res://bar.tscn"
@export var item_name: String = "phone"

var scene_change_triggered: bool = false
var last_selected_response: String = ""
var dialogue_label = null
var is_popup_visible: bool = false
var dialogue_has_ended: bool = false
var dialogue_in_progress: bool = false
var original_position: Vector2
var original_scale: Vector2
var original_z_index: int

func _ready() -> void:
	dialogue_file = "res://dialogues/phone_dialogue.dialogue"
	prompt_text = "📱 查看手机"
	
	super()
	
	enable_hover_hint = false
	if prompt_label:
		prompt_label.visible = false
		prompt_label.queue_free()
	
	original_position = position
	original_scale = scale
	original_z_index = z_index
	
	modulate.a = 0.0
	visible = false
	
	print("✓ " + item_name + " 初始化完成")

func _trigger_interact() -> void:
	if dialogue_in_progress:
		print("⚠️ " + item_name + " 对话进行中，忽略点击")
		return
	
	if dialogue_has_ended:
		print("⚠️ " + item_name + " 对话已完成，忽略点击")
		return
	
	if is_interacting:
		return
	
	is_interacting = true
	
	bring_to_front()
	hide_other_item()
	
	_on_interact()
	_unlock_after_delay()

func _unlock_after_delay() -> void:
	await get_tree().create_timer(0.2).timeout
	is_interacting = false

func bring_to_front():
	z_index = 100
	print("📱 " + item_name + " 置于最前")

func hide_other_item():
	var other_item_name = "earphone" if item_name == "phone" else "phone"
	var world = get_node_or_null("/root/world")
	if world:
		var other_item = world.find_node_recursive(world, other_item_name)
		if other_item and other_item.has_method("fade_out_temporarily"):
			other_item.fade_out_temporarily()

func fade_out_temporarily():
	var tween = create_tween()
	tween.tween_property(self, "modulate:a", 0.2, 0.3)

func restore_visibility():
	if is_popup_visible and not dialogue_in_progress:
		var tween = create_tween()
		tween.tween_property(self, "modulate:a", 1.0, 0.3)

func show_popup():
	if is_popup_visible:
		return
	
	is_popup_visible = true
	dialogue_has_ended = false
	dialogue_in_progress = false
	scene_change_triggered = false
	last_selected_response = ""
	visible = true
	
	print("📱 " + item_name + " 弹出动画开始...")
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	tween.tween_property(self, "modulate:a", 1.0, 0.3)
	
	scale = original_scale * 0.5
	tween.tween_property(self, "scale", original_scale, 0.3).set_trans(Tween.TRANS_BACK).set_ease(Tween.EASE_OUT)
	
	await tween.finished
	
	shake_item()

func shake_item():
	print("📳 " + item_name + " 震动中...")
	
	var shake_count = 6
	var shake_intensity = 8.0
	var shake_duration = 0.05
	
	for i in range(shake_count):
		var tween = create_tween()
		
		var offset = Vector2(
			randf_range(-shake_intensity, shake_intensity),
			randf_range(-shake_intensity, shake_intensity)
		)
		
		tween.tween_property(self, "position", original_position + offset, shake_duration)
		await tween.finished
	
	var tween = create_tween()
	tween.tween_property(self, "position", original_position, 0.1)
	await tween.finished
	
	print("✓ 震动完成")

func _input(event: InputEvent) -> void:
	if not is_popup_visible:
		return
	
	if not dialogue_has_ended:
		return
	
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			hide_item()

func hide_item():
	if not is_popup_visible:
		return
	
	print("📱 " + item_name + " 淡出...")
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	tween.tween_property(self, "modulate:a", 0.0, 0.5)
	tween.tween_property(self, "scale", original_scale * 0.8, 0.5)
	
	await tween.finished
	
	visible = false
	is_popup_visible = false
	z_index = original_z_index
	
	restore_other_item()
	
	var world = get_node_or_null("/root/world")
	if world and world.has_method("check_all_items_hidden"):
		world.check_all_items_hidden()
	
	print("✓ " + item_name + " 已隐藏")

func restore_other_item():
	var other_item_name = "earphone" if item_name == "phone" else "phone"
	var world = get_node_or_null("/root/world")
	if world:
		var other_item = world.find_node_recursive(world, other_item_name)
		if other_item and other_item.has_method("restore_visibility"):
			other_item.restore_visibility()

func _on_interact() -> void:
	print("\n==================================================")
	print(">>> " + item_name + " 被点击 <<<")
	print("==================================================")
	
	scene_change_triggered = false
	last_selected_response = ""
	dialogue_has_ended = false
	dialogue_in_progress = true
	
	show_dialogue()

func show_dialogue() -> void:
	print("  [1] 开始显示对话...")
	
	if not is_instance_valid(DialogueManager):
		print("  ❌ DialogueManager 不存在")
		dialogue_in_progress = false
		return
	
	if not FileAccess.file_exists(dialogue_file):
		print("  ❌ 对话文件不存在: " + dialogue_file)
		dialogue_in_progress = false
		return
	
	var dialogue_resource = load(dialogue_file)
	if dialogue_resource == null:
		print("  ❌ 无法加载对话")
		dialogue_in_progress = false
		return
	
	print("  [2] 对话资源加载成功")
	
	var balloon = DialogueManager.show_example_dialogue_balloon(dialogue_resource, "start")
	
	if balloon:
		print("  [3] 对话容器已创建")
		
		find_and_connect_signals(balloon)
		
		if DialogueManager.has_signal("dialogue_ended"):
			if DialogueManager.dialogue_ended.is_connected(_on_dialogue_ended):
				DialogueManager.dialogue_ended.disconnect(_on_dialogue_ended)
			DialogueManager.dialogue_ended.connect(_on_dialogue_ended)
			print("  ✓ 已连接 DialogueManager.dialogue_ended")
		
		print("\n  [4] 等待玩家选择...\n")

func find_and_connect_signals(node: Node, depth: int = 0):
	for sig in node.get_signal_list():
		var sig_name = sig.name
		
		if sig_name == "actioned":
			if not node.actioned.is_connected(_on_actioned):
				node.actioned.connect(_on_actioned)
				print("  ✓ 连接了 actioned 信号")
		
		if sig_name == "response_selected":
			if not node.response_selected.is_connected(_on_response_selected):
				node.response_selected.connect(_on_response_selected)
				print("  ✓ 连接了 response_selected 信号")
		
		if sig_name == "dialogue_ended":
			if not node.dialogue_ended.is_connected(_on_dialogue_ended):
				node.dialogue_ended.connect(_on_dialogue_ended)
	
	for child in node.get_children():
		find_and_connect_signals(child, depth + 1)

func _on_actioned(action):
	print("\n⚡ actioned 信号触发！")
	print("  数据: " + str(action))
	
	# 🔥 检查是否有 next_id 属性
	if "next_id" in action:
		var next_id = str(action.next_id)
		print("  → 跳转节点: " + next_id)
		
		if next_id == "midnight":
			scene_change_triggered = true
			print("  ✓✓✓ 检测到 midnight 节点！")

# 🔥 修复：DialogueResponse 对象的处理
func _on_response_selected(response):
	print("\n🎯 response_selected 信号触发！")
	print("  数据类型: " + str(response.get_class()))
	print("  数据: " + str(response))
	
	# 🔥 直接访问 .text 属性（不用 .has()）
	var response_text = ""
	
	# 尝试获取 text 属性
	if "text" in response:
		response_text = str(response.text)
	else:
		# 如果是 DialogueResponse 对象，直接转字符串
		response_text = str(response)
	
	last_selected_response = response_text
	print("  → 用户选择: " + last_selected_response)
	
	# 🔥 检测是否包含 "YES"（不区分大小写）
	var lower_text = last_selected_response.to_lower()
	if "yes" in lower_text:
		scene_change_triggered = true
		print("  ✓✓✓ 检测到 YES 选项，将切换场景！")

# 🔥 延迟检查机制
func _on_dialogue_ended(resource):
	print("\n📕 " + item_name + " 对话结束信号触发")
	print("  → 等待 0.2 秒让所有信号处理完...")
	
	# 等待一小段时间，让所有信号都处理完
	await get_tree().create_timer(0.2).timeout
	
	print("\n📕 " + item_name + " 对话真正结束！")
	print("  scene_change_triggered = " + str(scene_change_triggered))
	print("  last_selected_response = " + last_selected_response)
	
	# 🔥 最后检查：如果选择包含 YES，强制切换场景
	var lower_text = last_selected_response.to_lower()
	if "yes" in lower_text:
		scene_change_triggered = true
		print("  ✓ 通过文本检测，强制标记为切换场景")
	
	dialogue_has_ended = true
	dialogue_in_progress = false
	
	z_index = original_z_index
	restore_other_item()
	
	var world = get_node_or_null("/root/world")
	if world and world.has_method("mark_dialogue_completed"):
		world.mark_dialogue_completed(item_name)
	
	if scene_change_triggered:
		print("  ✓✓✓ 将切换场景到: " + target_scene)
		await get_tree().create_timer(0.5).timeout
		change_scene()
	else:
		print("  → 保持当前场景")
		print("  💡 提示：现在可以点击屏幕任意处隐藏物品")

func change_scene():
	print("\n🎬🎬🎬 开始切换场景 🎬🎬🎬")
	print("  目标场景: " + target_scene)
	
	if not FileAccess.file_exists(target_scene):
		print("  ❌ 场景文件不存在: " + target_scene)
		print("  → 请确认文件路径是否正确")
		return
	
	print("  ✓ 场景文件存在")
	print("  → 创建淡出效果...")
	
	var fade = ColorRect.new()
	fade.color = Color.BLACK
	fade.set_anchors_preset(Control.PRESET_FULL_RECT)
	fade.mouse_filter = Control.MOUSE_FILTER_IGNORE
	get_tree().root.add_child(fade)
	fade.modulate.a = 0.0
	
	print("  → 开始淡出动画...")
	var tween = create_tween()
	tween.tween_property(fade, "modulate:a", 1.0, 1.0)
	await tween.finished
	
	print("  → 执行场景切换...")
	var result = get_tree().change_scene_to_file(target_scene)
	
	if result == OK:
		print("  ✓✓✓ 场景切换成功！")
	else:
		print("  ❌ 场景切换失败，错误码: " + str(result))
