extends Interactable

@export var dialogue_file: String = "res://dialogues/earphone_dialogue.dialogue"  # ğŸ”¥
@export var target_scene: String = "res://bar.tscn"
@export var item_name: String = "earphone"  # ğŸ”¥

var midnight_shown: bool = false
var dialogue_label = null
var is_popup_visible: bool = false
var dialogue_has_ended: bool = false
var dialogue_started: bool = false  # ğŸ†• é˜²æ­¢é‡å¤è§¦å‘å¯¹è¯
var original_position: Vector2
var original_scale: Vector2
var original_z_index: int

func _ready() -> void:
	dialogue_file = "res://dialogues/earphone_dialogue.dialogue"  # ğŸ”¥
	prompt_text = "ğŸ§ æŸ¥çœ‹è€³æœº"  # ğŸ”¥
	
	super()
	
	enable_hover_hint = false
	if prompt_label:
		prompt_label.visible = false
		prompt_label.queue_free()
	
	original_position = position
	original_scale = scale
	original_z_index = z_index
	
	modulate.a = 0.0
	visible = false

func _trigger_interact() -> void:
	if is_interacting:
		return
	
	# ğŸ”¥ å¦‚æœå¯¹è¯å·²ç»ç»“æŸï¼Œä¸å†è§¦å‘
	if dialogue_has_ended:
		print("âš ï¸ " + item_name + " å¯¹è¯å·²å®Œæˆï¼Œä¸å†è§¦å‘")
		return
	
	# ğŸ”¥ å¦‚æœå¯¹è¯å·²ç»å¼€å§‹ï¼Œä¸å†è§¦å‘
	if dialogue_started:
		print("âš ï¸ " + item_name + " å¯¹è¯è¿›è¡Œä¸­ï¼Œä¸å†è§¦å‘")
		return
	
	is_interacting = true
	
	bring_to_front()
	hide_other_item()
	
	_on_interact()
	_unlock_after_delay()

func _unlock_after_delay() -> void:
	await get_tree().create_timer(0.2).timeout
	is_interacting = false

func bring_to_front():
	z_index = 100
	print("ğŸ“± " + item_name + " ç½®äºæœ€å‰")

func hide_other_item():
	var other_item_name = "earphone" if item_name == "phone" else "phone"
	var world = get_node_or_null("/root/world")
	if world:
		var other_item = world.find_node_recursive(world, other_item_name)
		if other_item and other_item.has_method("fade_out_temporarily"):
			other_item.fade_out_temporarily()
			print("ğŸ”‡ éšè— " + other_item_name)

func fade_out_temporarily():
	var tween = create_tween()
	tween.tween_property(self, "modulate:a", 0.2, 0.3)

func restore_visibility():
	if is_popup_visible and not dialogue_started:
		var tween = create_tween()
		tween.tween_property(self, "modulate:a", 1.0, 0.3)

func show_popup():
	if is_popup_visible:
		return
	
	is_popup_visible = true
	dialogue_has_ended = false
	dialogue_started = false  # ğŸ†• é‡ç½®
	visible = true
	
	print("ğŸ“± " + item_name + " å¼¹å‡ºåŠ¨ç”»å¼€å§‹...")
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	tween.tween_property(self, "modulate:a", 1.0, 0.3)
	
	scale = original_scale * 0.5
	tween.tween_property(self, "scale", original_scale, 0.3).set_trans(Tween.TRANS_BACK).set_ease(Tween.EASE_OUT)
	
	await tween.finished
	
	shake_item()

func shake_item():
	print("ğŸ“³ " + item_name + " éœ‡åŠ¨ä¸­...")
	
	var shake_count = 6
	var shake_intensity = 8.0
	var shake_duration = 0.05
	
	for i in range(shake_count):
		var tween = create_tween()
		
		var offset = Vector2(
			randf_range(-shake_intensity, shake_intensity),
			randf_range(-shake_intensity, shake_intensity)
		)
		
		tween.tween_property(self, "position", original_position + offset, shake_duration)
		await tween.finished
	
	var tween = create_tween()
	tween.tween_property(self, "position", original_position, 0.1)
	await tween.finished
	
	print("âœ“ éœ‡åŠ¨å®Œæˆ")

func _input(event: InputEvent) -> void:
	if not is_popup_visible:
		return
	
	if not dialogue_has_ended:
		return
	
	if event is InputEventMouseButton and event.pressed:
		if event.button_index == MOUSE_BUTTON_LEFT:
			hide_item()

func hide_item():
	if not is_popup_visible:
		return
	
	print("ğŸ“± " + item_name + " æ·¡å‡º...")
	
	var tween = create_tween()
	tween.set_parallel(true)
	
	tween.tween_property(self, "modulate:a", 0.0, 0.5)
	tween.tween_property(self, "scale", original_scale * 0.8, 0.5)
	
	await tween.finished
	
	visible = false
	is_popup_visible = false
	z_index = original_z_index
	
	restore_other_item()
	
	var world = get_node_or_null("/root/world")
	if world and world.has_method("check_all_items_hidden"):
		world.check_all_items_hidden()
	
	print("âœ“ " + item_name + " å·²éšè—")

func restore_other_item():
	var other_item_name = "earphone" if item_name == "phone" else "phone"
	var world = get_node_or_null("/root/world")
	if world:
		var other_item = world.find_node_recursive(world, other_item_name)
		if other_item and other_item.has_method("restore_visibility"):
			other_item.restore_visibility()
			print("ğŸ”Š æ¢å¤ " + other_item_name + " æ˜¾ç¤º")

func _on_interact() -> void:
	print("\n==================================================")
	print(">>> " + item_name + " è¢«ç‚¹å‡» <<<")
	print("==================================================")
	
	midnight_shown = false
	dialogue_has_ended = false
	dialogue_started = true  # ğŸ†• æ ‡è®°å¯¹è¯å·²å¼€å§‹
	show_dialogue()

func show_dialogue() -> void:
	print("  [1] å¼€å§‹æ˜¾ç¤ºå¯¹è¯...")
	
	if not is_instance_valid(DialogueManager):
		print("  âŒ DialogueManager ä¸å­˜åœ¨")
		return
	
	if not FileAccess.file_exists(dialogue_file):
		print("  âŒ å¯¹è¯æ–‡ä»¶ä¸å­˜åœ¨")
		return
	
	var dialogue_resource = load(dialogue_file)
	if dialogue_resource == null:
		print("  âŒ æ— æ³•åŠ è½½å¯¹è¯")
		return
	
	print("  [2] å¯¹è¯èµ„æºåŠ è½½æˆåŠŸ")
	
	var balloon = DialogueManager.show_example_dialogue_balloon(dialogue_resource, "start")
	
	if balloon:
		print("  [3] å¯¹è¯å®¹å™¨å·²åˆ›å»º")
		
		print("\nğŸ” æœç´¢å¯¹è¯æ§åˆ¶å™¨...")
		find_dialogue_controller(balloon)
		
		print("\nğŸ” è¿æ¥ DialogueManager å…¨å±€ä¿¡å·...")
		
		if DialogueManager.has_signal("dialogue_ended"):
			# ğŸ”¥ æ–­å¼€ä¹‹å‰çš„è¿æ¥ï¼Œé¿å…é‡å¤
			if DialogueManager.dialogue_ended.is_connected(_on_dialogue_ended):
				DialogueManager.dialogue_ended.disconnect(_on_dialogue_ended)
			DialogueManager.dialogue_ended.connect(_on_dialogue_ended)
			print("  âœ“ å·²è¿æ¥ DialogueManager.dialogue_ended")
		
		if DialogueManager.has_signal("passed"):
			if DialogueManager.passed.is_connected(_on_dialogue_passed):
				DialogueManager.passed.disconnect(_on_dialogue_passed)
			DialogueManager.passed.connect(_on_dialogue_passed)
			print("  âœ“ å·²è¿æ¥ DialogueManager.passed")
		
		print("\nğŸ” å¯åŠ¨æ–‡æœ¬ç›‘å¬...")
		start_dialogue_monitor()
		
		print("\n  [4] ç­‰å¾…ç©å®¶é€‰æ‹©...\n")

func find_dialogue_controller(node: Node, depth: int = 0):
	var indent = "  ".repeat(depth)
	
	for sig in node.get_signal_list():
		var sig_name = sig.name
		if "response" in sig_name or "action" in sig_name or "dialogue" in sig_name:
			
			if sig_name == "response_selected" and not node.response_selected.is_connected(_on_response_selected):
				node.response_selected.connect(_on_response_selected)
			
			if sig_name == "actioned" and not node.actioned.is_connected(_on_actioned):
				node.actioned.connect(_on_actioned)
			
			if sig_name == "dialogue_ended" and not node.dialogue_ended.is_connected(_on_dialogue_ended):
				node.dialogue_ended.connect(_on_dialogue_ended)
	
	for child in node.get_children():
		find_dialogue_controller(child, depth + 1)

func start_dialogue_monitor():
	var timer = Timer.new()
	timer.wait_time = 0.1
	timer.timeout.connect(_check_dialogue_content)
	add_child(timer)
	timer.start()
	
	await get_tree().create_timer(10.0).timeout
	if is_instance_valid(timer):
		timer.stop()
		timer.queue_free()

func _check_dialogue_content():
	var root = get_tree().root
	var labels = find_all_labels(root)
	
	for label in labels:
		if label.visible and label.text != "":
			var text = label.text
			
			if ("é’Ÿå£°å“èµ·" in text or "æ‰­æ›²" in text or "çœ©æ™•" in text) and not midnight_shown:
				midnight_shown = true
				print("\nâœ“âœ“âœ“ é€šè¿‡æ–‡æœ¬æ£€æµ‹åˆ° midnight å†…å®¹ï¼")
				print("  æ£€æµ‹åˆ°çš„æ–‡å­—: " + text.substr(0, min(50, text.length())))

func find_all_labels(node: Node) -> Array:
	var labels = []
	
	if node is Label or node is RichTextLabel:
		labels.append(node)
	
	for child in node.get_children():
		labels.append_array(find_all_labels(child))
	
	return labels

func _on_response_selected(response):
	print("\nğŸ¯ response_selected è§¦å‘ï¼")
	print("  æ•°æ®: " + str(response))
	
	if typeof(response) == TYPE_DICTIONARY and response.has("text"):
		var text = str(response.text)
		if "åˆå¤œ" in text or "12ç‚¹" in text:
			midnight_shown = true
			print("  âœ“âœ“âœ“ æ£€æµ‹åˆ° midnight é€‰é¡¹ï¼")

func _on_actioned(action):
	print("\nâš¡ actioned è§¦å‘ï¼")
	print("  æ•°æ®: " + str(action))
	
	if typeof(action) == TYPE_DICTIONARY:
		if action.has("next_id") and str(action.next_id) == "midnight":
			midnight_shown = true
			print("  âœ“âœ“âœ“ æ£€æµ‹åˆ° midnight èŠ‚ç‚¹ï¼")

func _on_dialogue_passed(data):
	print("\nğŸ² passed è§¦å‘ï¼")
	print("  æ•°æ®: " + str(data))

func _on_dialogue_ended(resource):
	print("\nğŸ“• " + item_name + " å¯¹è¯ç»“æŸï¼")
	print("  midnight_shown = " + str(midnight_shown))
	
	dialogue_has_ended = true
	dialogue_started = false  # ğŸ†• å¯¹è¯ç»“æŸï¼Œå¯ä»¥å†æ¬¡è§¦å‘
	
	z_index = original_z_index
	restore_other_item()
	
	# ğŸ”¥ é€šçŸ¥ world æ ‡è®°è¿™ä¸ªç‰©å“çš„å¯¹è¯å·²å®Œæˆ
	var world = get_node_or_null("/root/world")
	if world and world.has_method("mark_dialogue_completed"):
		world.mark_dialogue_completed(item_name)
	
	if midnight_shown:
		print("  âœ“ å°†åˆ‡æ¢åœºæ™¯")
		await get_tree().create_timer(0.5).timeout
		change_scene()
	else:
		print("  â†’ ä¿æŒå½“å‰åœºæ™¯")
		print("  ğŸ’¡ æç¤ºï¼šç°åœ¨å¯ä»¥ç‚¹å‡»å±å¹•ä»»æ„å¤„éšè—ç‰©å“")

func change_scene():
	print("\nğŸ¬ å¼€å§‹åˆ‡æ¢åœºæ™¯åˆ°: " + target_scene)
	
	if not FileAccess.file_exists(target_scene):
		print("âŒ åœºæ™¯æ–‡ä»¶ä¸å­˜åœ¨")
		return
	
	var fade = ColorRect.new()
	fade.color = Color.BLACK
	fade.set_anchors_preset(Control.PRESET_FULL_RECT)
	fade.mouse_filter = Control.MOUSE_FILTER_IGNORE
	get_tree().root.add_child(fade)
	fade.modulate.a = 0.0
	
	var tween = create_tween()
	tween.tween_property(fade, "modulate:a", 1.0, 1.0)
	await tween.finished
	
	print("åˆ‡æ¢åœºæ™¯...")
	get_tree().change_scene_to_file(target_scene)
	print("âœ“ å®Œæˆ")
